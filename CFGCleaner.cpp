// CFGCleaner.hpp
// Copyright (c) Lup Gratian
//
// Implements the CFGCleaner pass.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#include "CFGCleaner.hpp"
#include "../IR/IRPrinter.hpp"
#include <fstream>

namespace Optimization {

void CFGCleaner::Execute(Function* function, IRDominatorTree* domTree) {
    funct_ = function;
    IRGenerator irGen(function->ParentUnit());
    folder_ = ConstantFolder(&irGen, GetTarget());
    domTree_ = domTree;
    domTreeInvalidated_ = false;
    bool changed = true;

	// First remove all unreachable blocks, because they may interfere with the
	// transformations below. Such blocks are sometimes generated by the frontend.
	RemoveUnreachableBlocks();

    // We iterate until no further changes occur. The blocks are scanned in
    // postorder, so that the changes propagate faster.
    while(changed) {
        changed = false;

        // We try first to constant-fold the branching instructions.
        // This is done first because other simplifications
        // may hide this opportunity.
        for(auto block = function->FirstBlock(); block; block = block->NextBlock()) {
            if(ConstantFoldBranch(block)) {
			    changed = true;
		    }
        }

        if(changed) {
            // Remove all unreachable blocks before we continue.
            RemoveUnreachableBlocks();
            changed = false;
        }

        // The postorder list needs to be recomputed each time, because
        // reachability of the nodes may change between iterations.
        IRCFGInfo cfgInfo(function, false /* edgeInfoNeeded */);
        auto& list = cfgInfo.PostorderList();

        for(int i = 0; i < list.Count(); i++) {
            Block* block = const_cast<Block*>(list[i]);

            // Try to apply the simplifications.
            if(EliminateRedundantBranch(block)) {
                changed = true;
            }
            else if(EliminateEmptyBlock(block)) {
                changed = true;
            }
            else if(MergeWithPredecessor(block)) {
                changed = true;
            }
            else if(HoistBranch(block)) {
                changed = true;
            }
        }

        // All the following transformations could lead to
        // unreachable blocks (actually, the CFG could have had 
        // unreachable blocks from the beginning).
        if(changed) {
            RemoveUnreachableBlocks();
        }
    }    
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool CFGCleaner::EliminateRedundantBranch(Block* block) {
    DebugValidator::IsNotNull(block->BranchInstruction());

    // If we have a block that ends in an 'if', but the 'true' and 'false' blocks
    // are the same, we can replace it with an 'goto'.
    // if a, B, B -> goto B
    if(auto ifInstr = block->BranchInstruction()->As<IfInstr>()) {
        // We can compare the block references directly because references are unique.
        if(ifInstr->TrueTargetOp() == ifInstr->FalseTargetOp()) {
            // Replace by a 'goto'.
			auto conditionOp = ifInstr->ConditionOp();
            auto gotoInstr = GotoInstr::GetGoto(ifInstr->TrueTargetOp());
            block->ReplaceInstructionWith(ifInstr, gotoInstr);
            ifInstr->Free();

			// The condition is probably now a dead instruction, try to remove it.
			// This may allow us to eliminate this block completely.
            EliminateDeadInstructions(conditionOp);
            domTreeInvalidated_ = true;
			BlockSimplified(block, 0);
            return true;
        }
    }

    if(auto switchInstr = block->BranchInstruction()->As<SwitchInstr>()) {
        // Replace a 'switch' that always jumps to the same block with a 'goto'.
        // This doesn't happen often, but it's trivial to test for.
        auto defaultBlock = switchInstr->DefaultTargetOp();
        bool valid = true;

        for(int i = 0; i < switchInstr->CaseCount(); i++) {
            if(switchInstr->GetCase(i).Target != defaultBlock) {
                valid = false;
                break;
            }
        }

        if(valid) {
            // Replace by a 'goto'.
            auto conditionOp = switchInstr->ConditionOp();
            auto gotoInstr = GotoInstr::GetGoto(defaultBlock);
            block->ReplaceInstructionWith(switchInstr, gotoInstr);
            switchInstr->Free();

            // The condition is probably now a dead instruction, try to remove it.
            EliminateDeadInstructions(conditionOp);
            domTreeInvalidated_ = true;
			BlockSimplified(block, 0);
            return true;
        }

        // Replace a 'switch' that has a single 'case' by an 'if'.
        // switch a {              t = cmp a, 5
        //     5 : B1        ->    if t, B1, B2
        //     default: B2
        // }
        if(switchInstr->CaseCount() == 1) {
            auto intType = switchInstr->ConditionOp()->GetType();
            auto unit = block->ParentFunction()->ParentUnit();
            __int64 value = switchInstr->GetCase(0).Value;
            auto constantOp = unit->Constants().GetInt(intType, value);

            // Create the 'cmp' and 'if' instructions.
            auto temp = Temporary::GetTemporary(intType);
            auto cmpInstr = CmpInstr::GetCmp(Order_Equal, switchInstr->ConditionOp(),
                                             constantOp, temp);
            auto ifInstr = IfInstr::GetIf(temp, switchInstr->GetCase(0).Target,
                                          switchInstr->DefaultTargetOp());

            // Now replace the 'switch'.
            block->ReplaceInstructionWith(switchInstr, ifInstr);
            switchInstr->Free();
            block->InsertInstructionBefore(cmpInstr, ifInstr);
            domTreeInvalidated_ = true;
            return true;
        }
    }

    return EliminateRedundantIf(block);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool CFGCleaner::EliminateRedundantIf(Block* block) {
    // Consider the following situation:
    // B1: if t, B2, B3
    // B2: if t, B4, B3
    // The second 'if' is actually redundant, we can modify to CFG to:
    // B1: if t, B4, B3
    if((block->PredecessorCount() != 1) ||
       (block->InstructionCount() > 1)) {
       return false;
    }
    
    auto ifInstr = block->BranchInstruction()->As<IfInstr>();
   
    if(ifInstr == nullptr) {
        return false;
    }

    // The predecessor must also end with an 'if' that uses
    // the same condition operand.
    auto predecessor = block->PredecessorAt(0);
    auto predecessorIfInstr = predecessor->BranchInstruction()->As<IfInstr>();

    if((predecessorIfInstr == nullptr) ||
       (ifInstr->ConditionOp() != predecessorIfInstr->ConditionOp())) {
        return false;
    }

    // Test for the two possible cases (the 'false' or 'true' branches match).
    if((predecessorIfInstr->TrueTargetOp()->Target() == block) &&
       (predecessorIfInstr->FalseTargetOp() == ifInstr->FalseTargetOp())) {
        predecessor->ReplaceSuccessor(0, ifInstr->TrueTargetOp());
        return true;
    }
    else if((predecessorIfInstr->FalseTargetOp()->Target() == block) &&
            (predecessorIfInstr->TrueTargetOp() == ifInstr->TrueTargetOp())) {
        predecessor->ReplaceSuccessor(1, ifInstr->FalseTargetOp());
        return true;
    }

    return false;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CFGCleaner::EliminateDeadInstructions(Operand* op) {
    auto definingInstr = op->DefiningInstruction();

    if(definingInstr == nullptr) {
        return;
    }

    StaticList<Instruction*, 16> worklist;
    worklist.Add(definingInstr);

    while(worklist.IsNotEmpty()) {
        auto instr = worklist.RemoveLast();

        if(GetSafetyInfo()->IsDefinitelyDead(instr)) {
            // Put the operands on the worklist, because they may be dead now.
            for(int i = 0; i < instr->SourceOpCount(); i++) {
                if(auto definingInstr = instr->GetSourceOp(i)->DefiningInstruction()) {
                    worklist.Add(definingInstr);
                }
            }

            // Now remove the instruction.
            instr->RemoveFromBlock(true /* free */);
        }
    }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool CFGCleaner::MergeWithPredecessor(Block* block) {
    // Don't touch the entry block.
    if(block->IsFunctionEntry()) {
        return false;
    }

    // If this block has a single predecessor, and the predecessor
    // a single successor we can merge them to form a larger, equivalent block.
    if(block->PredecessorCount() == 1) {
		// If this is a loop formed of a single block don't try to merge.
        auto predecessorBlock = block->PredecessorAt(0);

		if((predecessorBlock == block) ||
           (predecessorBlock->SuccessorCount() != 1)) {
            return false;
        }
        
        // We can't merge them if we have a 'phi' node.
        // This can happen after some transformations.
        if(block->HasPhi()) {
            return false;
        }

        // They should not be merged if the predecessor has a 'phi' with
        // an incoming operand from this block - a cycle is formed.
        for(auto instr = predecessorBlock->FirstInstruction(); instr; 
            instr = instr->NextInstruction()) {
            if(auto phiInstr = instr->As<PhiInstr>()) {
                if(phiInstr->HasOperandFromBlock(block)) {
                    return false;
                }
            }
            else break;
        }

        // Update the Dominator Tree, if available. We need to do this
        // before we remove the block from the function.
        if(domTree_ && domTree_->HasBlock(predecessorBlock)) {
            domTree_->BlocksMerged(predecessorBlock, block);
        }
        else domTreeInvalidated_ = true;

        // Any block that had incoming values from 'block'
        // now has incoming values from 'predecessorBlock'.
        auto successorEnum = block->GetSuccessorEnum();

        while(successorEnum.IsValid()) {
            auto successorBlock = successorEnum.Next();
            BlockUtils::ReplacePhiOperandsBlock(successorBlock, block,
                                                predecessorBlock);
            SimplifyPhis(successorBlock);
        }

        // Merge the blocks; 'block' will be removed from the function.
        BlockUtils::MergeBlocks(predecessorBlock, block, false);
		BlockSimplified(predecessorBlock, 1);
		return true;
    }

	return false;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool CFGCleaner::EliminateEmptyBlock(Block* block) {
    // If we have a block 'A' that is empty, meaning that it contains only a
    // 'goto' to block 'B', we can change all the predecessors of 'A'
    // to jump directly to 'B'.
    // goto A      label A: goto B -> goto B
    // if a, C, A  label A: goto B -> if a, C, B
	// Note that we never eliminate the entry block.
    if(block->IsFirstBlock() ||
       (block->BranchInstruction()->IsGoto() == false)) {
        return false;
    }

    if(block->HasOnlyBranch() == false) {
        if(block->HasPhi()) {
            return EliminatePhiBlock(block);
        }
        else return false;
    }

    auto gotoInstr = block->BranchInstruction()->As<GotoInstr>();
    auto newTarget = gotoInstr->TargetOp()->Target();

    if(newTarget == block) {
        // This must be a dead loop, we ignore it here.
        return false;
    }

    // It may not be safe to do this simplification after we converted
    // the code to SSA for. Make sure there are no 'phi' conflicts.
    if(SafeToEliminateBlock(block, newTarget) == false) {
        return false;
    }

    // Make all predecessors jump directly.
    Block* newIncomingBlock = block;

    while(block->HasPredecessors()) {
        Block* predecessorBlock = block->PredecessorAt(0);
        
        // Replace 'block' with the block indicated by the 'goto'.
        // This handles all types of branching instructions.
        for(int j = 0; j < predecessorBlock->SuccessorCount(); j++) {
            if(predecessorBlock->SuccessorAt(j) == block) {
                if(BlockUtils::ReplacePhiOperandsBlock(newTarget, block, 
                                                       predecessorBlock)) {
                    newIncomingBlock = predecessorBlock;
                }
                else {
                    // The same operand that is incoming from 'newIncomingBlock'
                    // must be incoming from this predecessor too.
                    AddSamePhiOperand(newTarget, newIncomingBlock,
                                      predecessorBlock);
                }

                predecessorBlock->ReplaceSuccessor(j, newTarget);
            }
        }
    }

    // Sometimes the 'phi's simplify after this transformation.
    SimplifyPhis(newTarget);

    // The block can now be deleted.
    if(domTree_ && domTree_->HasBlock(block)) {
        domTree_->BlockRemoved(block);
    }
    else domTreeInvalidated_ = true;

	BlockSimplified(block, 2);
    funct_->RemoveBlock(block, true /* free */);
    return true;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CFGCleaner::AddSamePhiOperand(Block* block, Block* incomingBlock,
                                   Block* otherBlock) {
    // The operand that is incoming from 'incomingBlock'
    // must be incoming from 'otherBlock' too.
    auto unit = block->ParentFunction()->ParentUnit();
    auto instr = block->FirstInstruction();

    while(auto phiInstr = instr->As<PhiInstr>()) {
        // If there is already an operand incoming from 'otherBlock'
        // we skip this 'phi'. This can happen if we have the same
        // value incoming from more predecessors.
        if(phiInstr->HasOperandFromBlock(otherBlock)) {
            instr = instr->NextInstruction();
            continue;
        }

        auto incomingOp = phiInstr->GetOperandFromBlock(incomingBlock);
        DebugValidator::IsNotNull(incomingOp);
        auto otherBlockRef = unit->References().GetBlockRef(otherBlock);
        phiInstr->AddOperand(incomingOp, otherBlockRef);
        instr = instr->NextInstruction();
    }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool CFGCleaner::EliminatePhiBlock(Block* block) {
    // Sometimes we can eliminate a block that contains
    // only 'phi' instructions whose result is used
    // by other 'phi's in the single successor. For example,
    // label B2: t1 = phi {1, B0}, {2, B1}   ->   dead block
    //           goto B3                          removed later
    // label B3: t2 = phi {t1, B2}, {3, B4}       label B2: t2 = phi {1,2,3}
    auto gotoInstr = block->BranchInstruction()->As<GotoInstr>();
    auto newTarget = gotoInstr->TargetOp()->Target();

    if(newTarget == block) {
        // This must be a dead loop, we ignore it here.
        return false;
    }

    // Check if there are only 'phi's in the block.
    if(block->FirstNonPhi() != gotoInstr) {
    }
        return false;
    
    // We can eliminate the block only if the 'phi's have a single user 
    // that is a 'phi', and there is no conflict of the incoming operands
    // (there would be one in the example if 'B2' would already
    // have an incoming operand from 'B0' or 'B1').
    if(SafeToEliminateBlock(block, newTarget) == false) {
        return false;
    }
    else if(IsValidPhiBlock(block, newTarget) == false) {
        return false;
    }

    // All is OK, make the predecessors jump directly
    // to the unique successor. The operand that was incoming
    // from 'block' is removed and replaced by the operands
    // of the corresponding 'phi'.
    PatchPhiBlockTarget(newTarget, block);
       
    // Patch the predecessors of 'block' to jump to 'newTarget'.
    while(block->HasPredecessors()) {
        Block* predecessorBlock = block->PredecessorAt(0);
        
        for(int j = 0; j < predecessorBlock->SuccessorCount(); j++) {
            if(predecessorBlock->SuccessorAt(j) == block) {
                predecessorBlock->ReplaceSuccessor(j, newTarget);
            }
        }
    }

#if 1
    newTarget->ForEachPhiInstruction([newTarget](PhiInstr* instr) -> bool {
        for(int i = 0; i < instr->OperandCount(); i++) {
            auto incomingBlock = instr->GetOperandBlock(i)->Target();
            DebugValidator::IsTrue(newTarget->HasPredecessor(incomingBlock));
        }
        return true;
    });
#endif

    // The block can now be deleted.
    if(domTree_ && domTree_->HasBlock(block)) {
        domTree_->BlockRemoved(block);
    }
    else domTreeInvalidated_ = true;

	BlockSimplified(block, 6);
    funct_->RemoveBlock(block, true /* free */);
    return true;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void CFGCleaner::PatchPhiBlockTarget(Block* newTarget, Block* block) {
    // Make the predecessors jump directly to the unique successor. 
    // The operand that was incoming from 'block' is removed 
    // and replaced by the operands of the corresponding 'phi'.
    auto instr = newTarget->FirstInstruction();

    while(auto phiInstr = instr->As<PhiInstr>()) {
        auto incomingOp = phiInstr->GetOperandFromBlock(block);
        bool solved = false;

        // The first case handles the 'phi' instruction which is eliminated.
        if(auto incomingPhiInstr = incomingOp->DefiningInstrAs<PhiInstr>()) {
            if(incomingPhiInstr->ParentBlock() == block) {
                // Copy all incoming operands of the other 'phi'.
                for(int i = 0; i < incomingPhiInstr->OperandCount(); i++) {
                    phiInstr->AddOperand(incomingPhiInstr->GetOperand(i),
                                         incomingPhiInstr->GetOperandBlock(i));
                }

                phiInstr->RemoveOperand(block);
                solved = true;
            }
        }

        // The second case handles operands that are incoming from 
        // the block that contains the 'phi' to be eliminated, but which
        // is not the 'phi' - it might be a constant, for example.
        if(solved == false) {
            // We make the operand incoming from all predecessors of 'block'.
            block->ForEachPredecessor([phiInstr, incomingOp]
            (Block* block, int index) -> bool {
                auto unit = phiInstr->ParentFunction()->ParentUnit();
                auto blockRef = unit->References().GetBlockRef(block);
                phiInstr->AddOperand(incomingOp, blockRef);
                return true;
            });

            phiInstr->RemoveOperand(block);
        }

        instr = instr->NextInstruction();
    }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool CFGCleaner::IsValidPhiBlock(Block* block, Block* newTarget) {
    auto instr = block->FirstInstruction();
    
    while(auto phiInstr = instr->As<PhiInstr>()) {
        // An unused 'phi' will be deleted later.
        // Make sure the 'phi' has a single user.
        if((phiInstr->HasDestinationOp() == false) ||
           (phiInstr->ResultOp()->HasSingleUser() == false)) {
            return false;
        }
        
        if(auto phiUser = phiInstr->ResultOp()->GetUser(0)->As<PhiInstr>()) {
            // Make sure the 'phi' is found in the successor.
            if(phiUser->ParentBlock() != newTarget) {
                return false;
            }
        }
        else {
            // User is not a 'phi'.
            return false;
        }

        instr = instr->NextInstruction();
    }

    return true;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool CFGCleaner::SafeToEliminateBlock(Block* block, Block* newTarget) {
    // Safe if we have a single-successor, single-predecessor case.
    if(newTarget->HasSinglePredecessor()) {
        return true;
    }

    // It is not safe to eliminate an empty block if there is a 'phi' instruction
    // in the new target that has incoming values from both 'block' and at least
    // one of it's predecessors. 
    // An exception is when the incoming value is undefined, because we may 
    // assume it has any suitable value, and when the incoming value
    // is exactly the same that the one for the other predecessor.
    for(auto instr = newTarget->FirstInstruction(); instr; 
        instr = instr->NextInstruction()) {
        auto phiInstr = instr->As<PhiInstr>();
       
        if(phiInstr == nullptr) {
            break;
        }

        for(int i = 0; i < block->PredecessorCount(); i++) {
            auto predecessorBlock = block->PredecessorAt(i);
            auto incomingBlockOp = phiInstr->GetOperandFromBlock(block);
            auto incomingPredBlockOp = phiInstr->GetOperandFromBlock(predecessorBlock);

            if((incomingBlockOp && incomingPredBlockOp) && 
               (incomingBlockOp->IsUndefinedConstant() == false) &&
               (incomingPredBlockOp->IsUndefinedConstant() == false) &&
               (incomingBlockOp != incomingPredBlockOp)) {
                // Not safe, give up.
                return false;
            }
        }
    }

    return true;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool CFGCleaner::HoistBranch(Block* block) {
    // If we have a block that ends in a 'goto' (A), and it jumps to a block
    // that contains only an 'if' (B), we can hoist the 'if' into 'A' and
    // jump directly to 'C' or 'D'.
    //
    //    [A]            ---[A]---
    //     | /           |     / |
    //    [B] empty  ->  |  [B]  |    B may be unreachable now
    //   /   \           |       |
    // [C]   [D]        [C]     [D]
	// Note that this can be done only if the condition operand is defined
	// in a block that dominates 'A' (else we don't have a guarantee
    // that the operand is evaluated before reaching 'A').
    auto gotoInstr = block->BranchInstruction()->As<GotoInstr>();

    if(gotoInstr == nullptr) {
        return false;
    }
	
    auto target = gotoInstr->TargetOp()->Target();
    
    if(target->HasOnlyBranch() == false) {
        return false;
    }

    // We support only 'if'.
    auto ifInstr = target->BranchInstruction()->As<IfInstr>();

    if(ifInstr == nullptr) {
        return false;
    }

    // Check the dominance property.
    auto conditionOp = ifInstr->ConditionOp();

    if(GetSafetyInfo()->DefinitionDominatesBlock(conditionOp, block) == false) {
        // It isn't safe to hoist the branch.
        return false;
    }

    // 'C' and 'D' may contain 'phi' instructions that have an incoming value
    // from 'B'; make the incoming values indicate to 'A' instead.
    auto trueBlock = ifInstr->TrueTargetOp()->Target();
    auto falseBlock = ifInstr->FalseTargetOp()->Target();

    // A requirement is that no incoming value should be from 'block.
    if(SafeToHoistBranch(block, trueBlock, falseBlock) == false) {
        return false;
    }

    // The operands that were incoming from the block that contains the 'if'
    // must now be incoming from 'block'.
    BlockUtils::InsertSameIncoming(trueBlock, target, block);
    BlockUtils::InsertSameIncoming(falseBlock, target, block);

    // Remove the 'goto' and replace it by an 'if'.
    block->RemoveInstruction(block->BranchInstruction(), true /* free */);
    IfInstr::GetIf(ifInstr->ConditionOp(), ifInstr->TrueTargetOp(),
                   ifInstr->FalseTargetOp(), block);

    // If 'B' is now unreachable we remove it from the Dominator Tree.
    if(domTree_ && domTree_->HasBlock(target) && 
       (target->SuccessorCount() == 0)) {
        domTree_->BlockRemoved(target);
    }
    else domTreeInvalidated_ = true;

	BlockSimplified(block, 3);
    return true;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool CFGCleaner::SafeToHoistBranch(Block* replacementBlock, 
                                   Block* trueBlock, Block* falseBlock) {
    // An 'if' cannot be hoisted to 'replacementBlock' if either
    // 'trueBlock' or 'falseBlock' contain an incoming 'phi' operand from it.
    bool invalid = false;

    trueBlock->ForEachPhiInstruction([&invalid, replacementBlock]
                                     (PhiInstr* instr) -> bool {
        if(instr->HasOperandFromBlock(replacementBlock)) {
            invalid = true;
            return false; // Stop.
        }
        return true;
    });

    // Stop as soon as we're in an invalid case.
    if(invalid) return false;

    falseBlock->ForEachPhiInstruction([&invalid, replacementBlock]
                                      (PhiInstr* instr) -> bool {
        if(instr->HasOperandFromBlock(replacementBlock)) {
            invalid = true;
            return false; // Stop.
        }
        return true;
    });

    return invalid == false;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool CFGCleaner::ConstantFoldBranch(Block* block) {
	// An 'if'/'switch' branch may have a constant as it's 
    // condition operand (happens especially after function inlining).
	// In this case we know the outcome of the branch and we can
    // replace it with a 'goto'.
	auto branchingInstr = block->BranchInstruction();

	if(branchingInstr->IsGoto()) {
        return false;
    }

	auto targetBlock = folder_.FoldBranching(branchingInstr);

	if(targetBlock) {
        // Remove all incoming values from the successors that are not
        // reachable from 'block' anymore.
        auto successorEnum = block->GetSuccessorEnum();

        while(successorEnum.IsValid()) {
            auto successorBlock = successorEnum.Next();

            if(successorBlock != targetBlock->Target()) {
                RemoveIncomingFromBlock(successorBlock, block);
            }
        }

		// Replace by a 'goto'.
		auto gotoInstr = GotoInstr::GetGoto(targetBlock);
		block->ReplaceInstructionWith(branchingInstr, gotoInstr);
		branchingInstr->Free();

        domTreeInvalidated_ = true;
        BlockSimplified(block, 4);
		return true;
	}

	// If we have a 'switch' and a 'phi' instruction as the condition
	// we may be able to eliminate some of the 'case' targets, in case the 'phi'
	// operands are all constants (note that not the same constant is required).
	auto switchInstr = branchingInstr->As<SwitchInstr>();

	if(switchInstr == nullptr) {
        return nullptr;
    }

	auto phiInstr = branchingInstr->GetSourceOp(0)->DefiningInstrAs<PhiInstr>();

    if((phiInstr == nullptr) ||
	   (phiInstr->HasOnlyConstants() == false)) {
        return false;
    }

	// Scan the list of 'case' values. If the value is not found among
	// the operands of the 'phi' it means that the target can never be taken.
	Dictionary<__int64, int> phiOps;
	auto caseList = switchInstr->CaseList();
	bool changed = false;

	for(int i = 0; i < phiInstr->OperandCount(); i++) {
        auto op = phiInstr->GetOperand(i);

        if(auto intConst = phiInstr->GetOperand(i)->As<IntConstant>()) {
		    phiOps.Add(intConst->Value(), i);
        }
        else return false;
	}

	for(int i = caseList.Count() - 1; i >= 0; i--) {
		if(phiOps.ContainsKey(caseList[i].Value) == false) {
			// This 'case' is unreachable, remove it; the associated block
			// will be removed later.
            auto targetBlock = switchInstr->GetCase(i).Target;
            RemoveIncomingFromBlock(targetBlock->Target(), block);
			switchInstr->RemoveCase(i);

			changed = true;
            domTreeInvalidated_ = true;
		}
	}

	return changed;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
bool CFGCleaner::RemoveUnreachableBlocks() {
    // A block is definitely unreachable if it has no predecessors,
    // or if all it's predecessors are unreachable.
    // Perform a depth-first search of the CFG and mark all reachable blocks.
    // All blocks that are not marked now are definitely unreachable.
    bool changed = false;
    
    reachable_.Clear();
    DepthFirstWalker<Block, ReachableMarker>().Walk(funct_->FirstBlock(), 
                                                    ReachableMarker(this));

    // When we scan the first time we don't remove the blocks,
    // because otherwise in case of loops we may access 
    // blocks that were deleted.
    auto block = funct_->FirstBlock();
    StaticList<Block*, 16> removedBlocks;

    while(block) {
        auto nextBlock = block->NextBlock();

        if(reachable_.IsSet(block->Id()) == false) {
            // The block can be removed.
            ClearBlock(block);
			removedBlocks.Add(block);

            changed = true;
            domTreeInvalidated_ = true;
            BlockSimplified(block, 5);
        }

        block = nextBlock;
    }

    // Now delete the unreachable blocks.
    for(int i = 0; i < removedBlocks.Count(); i++) {
        // Remove the block.
        funct_->RemoveBlock(removedBlocks[i], true /* free */);
    }

    return changed;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
void CFGCleaner::MarkReachable(const Block* block) {
    // This block is reachable from entry.
    reachable_.SetBit(block->Id());
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
void CFGCleaner::ClearBlock(Block* block) {
    // For each instruction, make the user use 'undef' instead of the result
    // of the instruction. Most of these users will be cleared later.
    auto unit = block->ParentFunction()->ParentUnit();

    for(auto instr = block->FirstInstruction(); instr; 
        instr = instr->NextInstruction()) {
        if(instr->HasDestinationOp() == false) {
            continue;
        }

        // If we have an user that is a 'phi' instruction we need
        // to remove the incoming value completely.
        auto destOp = instr->GetDestinationOp();
        StaticList<Instruction*, 4> externalUsers;
        StaticList<PhiInstr*, 4> phiUsers;

        destOp->ForEachUser([block, &externalUsers, &phiUsers]
                            (Instruction* user, int index) -> bool {
            if(auto phiInstr = user->As<PhiInstr>()) {
                phiUsers.Add(phiInstr);
            }
            else if(user->ParentBlock() != block) {
                externalUsers.Add(user);
            }

            return true;
        });

        for(int i = 0; i < phiUsers.Count(); i++) {
            phiUsers[i]->RemoveOperand(block);
        }

        // Replace with 'undef' the users that are not in this block.
        if(externalUsers.Count() > 0) {
            auto type = instr->GetDestinationOp()->GetType();
            auto undefOp = unit->Constants().GetUndefined(type);

            for(int i = 0; i < externalUsers.Count(); i++) {
                auto user = externalUsers[i];

                for(int j = 0; j < user->SourceOpCount(); j++) {
                    if(user->GetSourceOp(j) == destOp) {
                        user->ReplaceSourceOp(j, undefOp);
                    }
                }
            }
        }
    }

    // There may be successors that have an incoming value from this block
    // which is a constant; it must be removed too.
    auto successorEnum = block->GetSuccessorEnum();

    while(successorEnum.IsValid()) {
        auto successorBlock = successorEnum.Next();
        RemoveIncomingFromBlock(successorBlock, block);
        successorBlock->RemovePredecessor(block);
    }

    // Unlink the block from it's successors.
    block->DropLinks();
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
void CFGCleaner::RemoveIncomingFromBlock(Block* toBlock, Block* fromBlock) {
    for(auto instr = toBlock->FirstInstruction(); instr; 
        instr = instr->NextInstruction()) {
        auto phiInstr = instr->As<PhiInstr>();
        
        if(phiInstr == nullptr) {
            break;
        }

        phiInstr->RemoveOperand(fromBlock);
    }

    SimplifyPhis(toBlock);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Operand* CFGCleaner::SimplifyPhi(PhiInstr* instr) {
    // It's possible that the 'phi' remained without operands
    // because the parent block is no longer reachable.
    if(instr->OperandCount() == 0) {
        return nullptr;
    }

    // We must be sure that none of the users will be replaced by itself,
    // because this is not valid. It can happen if a loop
    // is no longer reachable, for example.
    Operand* singleOp = nullptr;

    if(instr->HasSingleOperand()) {
        singleOp = instr->GetOperand(0);
    }
    else if(instr->SameOperands()) {
        singleOp = instr->GetOperand(0);
    }
    
    if(singleOp == nullptr) {
        return nullptr;
    }
    
    if(auto temp = singleOp->As<Temporary>()) {
        auto userEnum = instr->ResultOp()->GetUserEnumerator();

        while(userEnum.IsValid()) {
            auto user = userEnum.Next();

            if(user->HasDestinationOp() &&
               (user->GetDestinationOp() == singleOp)) {
                // Give up, we would end with an instruction
                // that uses its result operand!
                return nullptr;
            }
        }
    }

    return singleOp;
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
void CFGCleaner::SimplifyPhis(Block* block) {
    // Try to simplify the 'phi' instructions.
    auto phiInstr = block->FirstInstruction()->As<PhiInstr>();

    while(phiInstr) {
        auto nextPhiInstr = phiInstr->NextInstruction() ? 
                            phiInstr->NextInstruction()->As<PhiInstr>() : nullptr;

        if(auto result = SimplifyPhi(phiInstr)) {
            phiInstr->ResultOp()->ReplaceWith(result);
            phiInstr->RemoveFromBlock(true /* free */);
        }

        phiInstr = nextPhiInstr;
    }
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
void CFGCleaner::BlockSimplified(Block* block, int type) {
#if 1
	auto function = block->ParentFunction();
	string blockName = block && block->HasName() ? *block->Name() : "UNTITLED";
	string functionName = function && function->HasName() ? *function->Name() : "UNTITLED";
    string text = "Block cleaned in " + functionName + ":" + blockName;

    switch(type) {
        case 0: text += " (redundant if)"; break;
        case 1: text += " (merge with pred)"; break;
        case 2: text += " (empty block)"; break;
        case 3: text += " (hoist branch)"; break;
        case 4: text += " (constant folding)"; break;
        case 5: text += " (unreachable)"; break;
        case 6: text += " (empty PHI block)"; break;
    }

	Log::Warning(text);
    if(*function->Name() == "readMasterJournal") 
    {
        IRPrinter p(function);
        std::wofstream f("d:\\test\\out_opt.irl");
        f<<p.ToString().Chars();
        f.close();

        for(auto block = function->FirstBlock(); block; block = block->NextBlock()) {
            block->ForEachPhiInstruction([block](PhiInstr* instr) -> bool {
                for(int i = 0; i < block->PredecessorCount(); i++) {
                    auto pred = block->PredecessorAt(i);

                    if(pred->HasPredecessors() == false) {
                        continue;
                    }

                    DebugValidator::IsNotNull(instr->GetOperandFromBlock(pred));
                }
                return true;
            });
        }

                 
                }
    //IRPrinter(funct_).Dump();
    //funct_->ViewCFG();
#endif
}

} // namespace Optimization;